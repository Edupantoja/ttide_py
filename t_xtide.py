# Autogenerated with SMOP version 0.23
# main.py ../t_tide1.3/t_xtide.m -o ../t_tide_py/t_xtide.py
from __future__ import division
import numpy as np
from scipy.io import loadmat,savemat
import os

def t_xtide(*varargin):
    """T_XTIDE Tidal prediction
     YOUT=T_XTIDE(STATION) makes a tidal prediction
     for the current day using the harmonics file from XTIDE. 
     if STATION is a string then the first match found in the database is
     used, you can request matches to other stations by appending '(2)' to
     the string. If you don't know the station name but want to find the
     nearest to a given LONG,LAT, try T_XTIDE(LONG,LAT).

     The times of predicted tides are given by the next numerical argument
     (if any), e.g. [...]=T_XTIDE(STATION,TIM). 
     TIM can be: a vector of matlab-format decimal days (from DATENUM).
               : a scalar <1000, taken as the number of days from present
               : a scalar >1000, taken as the starting time in matlab-format 
                 for a 2 day time series. 
               : not given, in which case the current time is used as a start 
                 time.

     Times are usually taken to be in 
     standard time for the given location (no daylight savings adjustments); 
     if in doubt use the 'info' or 'full' options where offset from UTC is given.


     Other optional arguments can be specified following this using 
     property/value pairs: 

         'format'     'raw' (default)
                        YOUT is just a time series to match the time in TIM

                      'times'
                        YOUT is a structure of high/low tide information
                        between times min(TIM) and max(TIM).

                      'info'
                        YOUT is a structure giving station information
                        (location, time zone, units, harmonic constituents)

                      'full'
                        Combination of 'raw' and 'info' in a structure YOUT.

         'units'     {'meters' | 'feet' | 'm/s' | 'knots' | 'original' }
                        Units of result (default is original units)

     If no output argument is specified data is plotted and/or displayed.

     If the chosen name matches several stations then the first in the list is
     chosen. Specific choices can be made by appending a '(2)' or '(3)' (etc.)
     to the name, e.g.  T_XTIDE('tofino (2)',...).

      Requires the xtide harmonics file  - get this from 
                http://bel-marduk.unh.edu/xtide/files.html
     R. Pawlowicz 1/Dec/2001
     Version 1.0
              16/May/02 - added lat/long options (thanks to Richard Dewey).
     Get the harmonics data from a) a mat-file if it exists, or b) from a harmonics
     file.
    """
    nargin = len(varargin)
    if nargin > 0:
        varargin = varargin[0]
    if not  os.path.exists('t_xtide.mat'):
        # Read the harmonics file and make a mat file
        filnam = '/usr/share/xtide/harmonics.txt'
        fprintf("\\n********Can't find mat-file t_xtide.mat ********\\n\\n")
        fprintf('Attempting to generate one from an xtide harmonics file....\\n\\n')
        fprintf('Latest version available from http://bel-marduk.unh.edu/xtide/files.html\\n\\n')
        # Input name
        fid = - 1
        while fid == - 1:

            rep = filnam
            while (lower(rep[0]) != 'y'):

                filnam = rep
                rep = 'n'
                rep = input_('Harmonics filename: ' + filnam + '? (y/Y/new file name):', 's')
                if (0 in rep.shape):
                    rep = 'y'

            fid = open(filnam)
            if fid == - 1:
                fprintf("\\n****** Can't open filename ->" + filnam + '<-\\n\\n')

        fprintf('Reading harmonics file (this will take a while)\\n')
        xtide, xharm = read_xtidefile(fid) # nargout=2
        fprintf('Saving harmonic information to t_xtide.mat\\n')
        savemat('t_xtide', 'xtide', 'xharm')
    else:
        loadmat('t_xtide',matlab_compatible=True)
    if nargin > 0:
        if isstr(varargin[0]):
            # Station  name given
            # Identify station - look for exact match first
            ista = strmatch(lower(varargin[0]), lower(xharm.station), 'exact')
            # otherwise go for partial matches
            if (0 in ista.shape):
                # First check to see if a number was selected:
                inum = - 10
                while inum < - 1:

                    inum = inum + 1
                    ll = findstr(lower(varargin[0]), sprintf('(\n %d)', - inum))
                    if not  (0 in ll.shape):
                        inum = abs(inum)
                        varargin[0] = deblank(varargin[0](range(1, (ll - 1 +1))))

                ista = strmatch(lower(varargin[0]), lower(xharm.station))
                if max(ista.shape) > 1:
                    if inum > 0 & inum <= max(ista.shape):
                        ista = ista[(inum -1)]
                    else:
                        fprintf('Ambiguous Station Choice - Taking first of:\\n')
                        for kk in range(1, (max(ista.shape) +1)):
                            fprintf('\n %5d: \n %s\\n', ista[(kk -1)], deblank(xharm.station(ista[(kk -1)], :)))
                            fprintf('      Long: \n %.4f  Lat: \n %.4f \\n', xharm.longitude(ista[(kk -1)]), xharm.latitude(ista[(kk -1)]))
                        fprintf('\\n')
                        ista = ista[0]
                else:
                    if max(ista.shape) == 1 & inum > 1:
                        fprintf("***Can't find variant (\n %d) of station - Taking only choice\\n", inum)
                    else:
                        if max(ista.shape) == 0:
                            error('Could not match station')
            varargin[0] = np.array([])
        else:
            # Lat/long?
            dist, hdg = t_gcdist(xharm.latitude, xharm.longitude, varargin[1], varargin[0]) # nargout=2
            mind, ista = np.min(dist) # nargout=2
            if max(ista.shape) > 1:
                fprintf('Ambiguous Station Choice - Taking first of:\\n')
                for kk in range(1, (max(ista.shape) +1)):
                    fprintf('\n %5d: \n %s\\n', ista[(kk -1)], deblank(xharm.station(ista[(kk -1)], :)))
                    fprintf('      Long: \n %.4f  Lat: \n %.4f \\n', xharm.longitude(ista[(kk -1)]), xharm.latitude(ista[(kk -1)]))
                fprintf('\\n')
                ista = ista[0]
            else:
                fprintf('\n %5d: \n %s\\n', ista, deblank(xharm.station(ista, :)))
                fprintf('      Long: \n %.4f  Lat: \n %.4f \\n', xharm.longitude(ista), xharm.latitude(ista))
            varargin[0:2] = np.array([])
        # Time vector (if available) otherwise take current time.
        if max(varargin.shape) > 0 & not  isstr(varargin[0]):
            tim = varargin[0]
            tim = tim[:].T
            varargin[0] = np.array([])
            if max(tim.shape) == 1:
                if tim < 1000:
                    dat = clock
                    tim = datenum(dat[0], dat[1], dat[2]) + np.array([range(0, (tim +1), 1 / 48)]).reshape(1, -1)
                else:
                    tim = tim + np.array([range(0, 3, 1 / 48)]).reshape(1, -1)
                    # 2 days worth.
        else:
            dat = clock
            tim = datenum(dat[0], dat[1], dat[2]) + np.array([range(0, 49, 0.25)]).reshape(1, -1) / 24
        # Parse properties
        format_ = 'raw'
        unt = 'original'
        k = 1
        while max(varargin.shape) > 0:

            if 'for' == lower(varargin[-1](range(1, 4))):
                format_ = lower(varargin[1])
            else:
                if 'uni' == lower(varargin[-1](range(1, 4))):
                    unt = lower(varargin[1])
                else:
                    error("Can't understand property:" + varargin[0])
            varargin[(np.array([1, 2]).reshape(1, -1) -1)] = np.array([])

        # if we want a time series
        pred = np.array([])
        # Convert units if requested.
        units, convf = convert_units(unt, xharm.units(ista, :)) # nargout=2
        if format_[0:2] == 'ra' | format_[0:2] == 'fu' | format_[0:2] == 'ti':
            # Data every minute for hi/lo forecasting.
            if format_[0:2] == 'ti':
                tim = range(tim[0], (tim[-1] +1), (1 / 1440))
            # Convert into time since the beginning of year
            mid = datevec(mean(tim))
            iyr = mid[0] - xtide.startyear + 1
            lt = max(tim.shape)
            xtim = np.dot((tim - datenum(mid[0], 1, 1)), 24)
            # Hours since beginning of year
            #-----------------------------------------------------
            # Sum up everything for the prediction!
            pred = xharm.datum(ista) + np.sum(repmat(xtide.nodefactor(:, iyr) * xharm.A(ista, :).T, 1, lt) * cos(np.dot((np.dot(xtide.speed, xtim) + repmat(xtide.equilibarg(:, iyr) - xharm.kappa(ista, :).T, 1, lt)), (pi / 180))), 1)
            #-----------------------------------------------------
            pred = np.dot(pred, convf)
            # Compute times of hi/lo from every-minute data
            if format_[0:2] == 'ti':
                # Check if this is a current station
                if not  (0 in findstr('Current', xharm.station(ista, :)).shape):
                    currents = 1
                else:
                    currents = 0
                dpred = diff(pred)
                ddpred = diff(dpred > 0)
                flat = np.flatnonzero(ddpred != 0) + 1
                slk = np.flatnonzero(sign(pred[0:pred.shape[0] - 1]) != sign(pred[1:pred.shape[0]]))
                hi.mtime = tim[(flat -1)]
                hi.value = pred[(flat -1)]
                hi.type = np.zeros(shape=(flat.shape, flat.shape), dtype='float64')
                hi.type(np.flatnonzero(ddpred[(flat - 1 -1)] < 0)) = 1
                # 0=lo, 1=hi
                hi.units = deblank(units)
                pred = hi
        # Create information structure
        if format_[0:2] == 'in' | format_[0:2] == 'fu':
            if not  (0 in pred.shape):
                pred.yout = pred
                pred.mtime = tim
            else:
                kk = np.flatnonzero(xharm.A(ista, :) != 0)
                pred.freq = xtide.name(kk, :)
                pred.A = np.dot(full(xharm.A(ista, kk).T), convf)
                pred.kappa = full(xharm.kappa(ista, kk).T)
            pred.station = deblank(xharm.station(ista, :))
            pred.longitude = xharm.longitude(ista)
            pred.latitude = xharm.latitude(ista)
            pred.timezone = xharm.timezone(ista)
            pred.units = deblank(units)
            pred.datum = np.dot(xharm.datum(ista), convf)
    # If no output parameters then we plot or display things
    if nargout == 0:
        if 'ti' == format_[(((0:2 -1) -1) -1)]:
            fprintf('High/Low Predictions for \n %s\\n', xharm.station(ista, :))
            fprintf('Time offset \n %.1f from UTC\\n\\n', xharm.timezone(ista))
            outstr = repmat(' ', max(flat.shape), 41)
            outstr[:, 0:20] = datestr(hi.mtime)
            outstr[:, 21:27] = reshape(sprintf('\n %6.2f', hi.value), 6, max(flat.shape)).T
            if currents:
                ll = hi.type == 1
                outstr[(ll -1), 30:41] = repmat(' Flood Tide', np.sum(ll), 1)
                ll = hi.type == 0
                outstr[(ll -1), 30:41] = repmat(' Ebb Tide  ', np.sum(ll), 1)
            else:
                ll = hi.type == 1
                outstr[(ll -1), 30:41] = repmat(' High Tide ', np.sum(ll), 1)
                ll = hi.type == 0
                outstr[(ll -1), 30:41] = repmat(' Low Tide  ', np.sum(ll), 1)
            disp(outstr)
        else:
            if 'ra' == format_[(((0:2 -1) -1) -1)]:
                plot(tim, pred)
                datetick
                title('Tidal prediction for ' + deblank(xharm.station(ista, :)) + ' beginning ' + datestr(tim[0]))
                ylabel(deblank(xharm.units(ista, :)))
            else:
                if 'fu' == format_[(((0:2 -1) -1) -1)]:
                    plot(tim, pred.yout)
                    datetick
                    title('Tidal prediction for ' + deblank(xharm.station(ista, :)) + ' beginning ' + datestr(tim[0]))
                    ylabel(deblank(xharm.units(ista, :)))
                else:
                    if 'in' == format_[(((0:2 -1) -1) -1)]:
                        fprintf('Station: \n %s\\n', pred.station)
                        if pred.longitude < 0:
                            lon = 'W'
                        else:
                            lon = 'E'
                        if pred.latitude < 0:
                            lat = 'S'
                        else:
                            lat = 'N'
                        fprintf("Location: \n %d \n %.1f' \n %c, \n %d \n %.1f' \n %c\\n", fix(abs(pred.latitude)), np.dot(rem(abs(pred.latitude), 1), 60), lat, fix(abs(pred.longitude)), np.dot(rem(abs(pred.longitude), 1), 60), lon)
                        fprintf('Time offset \n %.1f from UTC\\n\\n', pred.timezone)
        clear('pred')
    #
    return pred
def read_xtidefile(fid):
    """Reads the xtide harmonics file and creates a data structure
     with all that info for faster access
    """
    l = fgetl_nocom(fid)
    ncon = sscanf(l, '\n %d')
    xtide = type('struct', (), {})()
    for k in range(1, (ncon +1)):
        l = fgetl_nocom(fid)
        xtide.name(k, :) = l[0:8]
        xtide.speed(k) = sscanf(l[8:l.shape[0]], '\n %f')
    xtide.startyear = sscanf(fgetl_nocom(fid), '\n %d')
    nyear = sscanf(fgetl_nocom(fid), '\n %d')
    for k in range(1, (ncon +1)):
        l = fgetl(fid)
        xtide.equilibarg(k, :) = fscanf(fid, '\n %f', nyear)
        l = fgetl(fid)
    l = fgetl(fid)
    # Skip *END*
    nyear = sscanf(fgetl_nocom(fid), '\n %d')
    for k in range(1, (ncon +1)):
        l = fgetl(fid)
        xtide.nodefactor(k, :) = fscanf(fid, '\n %f', nyear)
        l = fgetl(fid)
    l = fgetl(fid)
    # Skip *END*
    # Now read in all harmonic data
    #nsta=1754; 
    # This is number of stations in harmonics (1998-07-18)
    #nsta=3351; 
    # This is number of stations in v1.42 or harmonics file
    nsta = 3316
    # This is number in v1.51
    xharm = type('struct', (), {})()
    nh = 0
    while max(l.shape) > 0 & l[0] != - 1:

        l = l + '   '
        nh = nh + 1
        while not  l[0:3] == '# !':

            l = fgetl(fid) + '   '

        while l[0:3] == '# !':

            if 'unit' == l[((3:7 -1) -1)]:
                tmp = deblank(l[(findstr(l, ':') + 2 -1):l.shape[0]])
                xharm.units(nh, range(1, (max(tmp.shape) +1))) = tmp
            else:
                if 'long' == l[((3:7 -1) -1)]:
                    xharm.longitude(nh) = sscanf(l[(findstr(l, ':') + 1 -1):l.shape[0]], '\n %f')
                else:
                    if 'lati' == l[((3:7 -1) -1)]:
                        xharm.latitude(nh) = sscanf(l[(findstr(l, ':') + 1 -1):l.shape[0]], '\n %f')
            l = fgetl(fid)

        tmp = deblank(l)
        if tmp[0] != '#':
            # Not commented out
            xharm.station(nh, range(1, (max(tmp.shape) +1))) = tmp
            tmp = fgetl(fid)
            k = np.min(findstr(tmp, ':'))
            tim = sscanf(tmp[0:k - 1], '\n %d') + sscanf(tmp[(k + np.array([range(1, 3)]).reshape(1, -1) -1)], '\n %d') / 60
            xharm.timezone(nh) = tim
            tmp = fgetl(fid)
            xharm.datum(nh) = sscanf(tmp, '\n %f')
            for k in range(1, (ncon +1)):
                l = fgetl(fid)
                if l[0] != 'x':
                    ll = np.min(np.array([findstr(' ', l), np.flatnonzero(abs(l) == 9)]).reshape(1, -1))
                    # space or tab
                    tmp = sscanf(l[(ll + 1 -1):l.shape[0]], '\n %f', 2)
                    xharm.A(nh, k) = tmp[0]
                    xharm.kappa(nh, k) = tmp[1]
            l = fgetl(fid)
        else:
            nh = nh - 1
        if rem(nh, 50) == 0:
            fprintf('.')

    fprintf('\\n')
    # Convert internally to sparse matrix storage (much smaller).
    xharm.A = sparse(xharm.A)
    xharm.kappa = sparse(xharm.kappa)
    return xtide, xharm
    #  
    return xtide, xharm
def fgetl_nocom(fid):
    """Gets a line that isn't a comment line

    """
    l = fgetl(fid)
    while max(l.shape) > 0 & l[0] == '#':

        l = fgetl(fid)

    #
    return l
def convert_units(unt, origunits):
    """Conversion factors from origianl units if requested and possible
     (no conversions from knots to feet).

    """
    if unt[0:3] == origunits[0:3] | unt[0:3] == 'ori':
        units = origunits
        convf = 1
    else:
        if 'fee' == unt[(((0:3 -1) -1) -1)]:
            if origunits[0:3] == 'met':
                units = 'feet'
                convf = 3.2808399
            else:
                units = origunits
                convf = 1
        else:
            if 'met' == unt[(((0:3 -1) -1) -1)]:
                if origunits[0:3] == 'fee':
                    units = 'meters'
                    convf = 0.3048
                else:
                    units = origunits
                    convf = 1
            else:
                if 'm/s' == unt[(((0:3 -1) -1) -1)]:
                    if origunits[0:3] == 'kno':
                        units = 'meters/sec'
                        convf = 0.51444444
                    else:
                        units = origunits
                        convf = 1
                else:
                    if 'kno' == unt[(((0:3 -1) -1) -1)]:
                        if origunits[0:3] == 'm/s':
                            units = 'knots'
                            convf = 1.9438445
                        else:
                            units = origunits
                            convf = 1
                    else:
                        error('Unknown units')
    #
    return units, convf
def t_gcdist(lat1, lon1, lat2, lon2):
    """function [d,hdg]=t_gcdist(lat1,lon1,lat2,lon2)
     Function to calculate distance in kilometers and heading between two
     positions in latitude and longitude.
     Assumes -90 > lat > 90  and  -180 > long > 180
        north and east are positive
     Uses law of cosines in spherical coordinates to calculate distance
     calculate conversion constants

      Code from Richard Dewey.
    """
    raddeg = 180 / pi
    degrad = 1 / raddeg
    # convert latitude and longitude to radians
    lat1 = lat1 * degrad
    lat2 = lat2 * degrad
    in1 = np.flatnonzero(lon1 > 180)
    lon1[(in1 -1)] = lon1[(in1 -1)] - 360
    in2 = np.flatnonzero(lon2 > 180)
    lon2[(in2 -1)] = lon2[(in2 -1)] - 360
    lon1 = - lon1 * degrad
    lon2 = - lon2 * degrad
    # calculate some basic functions
    coslat1 = cos(lat1)
    sinlat1 = sin(lat1)
    coslat2 = cos(lat2)
    sinlat2 = sin(lat2)
    #calculate distance on unit sphere
    dtmp = cos(lon1 - lon2)
    dtmp = sinlat1 * sinlat2 + coslat1 * coslat2 * dtmp
    # check for invalid values due to roundoff errors
    in1 = np.flatnonzero(dtmp > 1.0)
    dtmp[(in1 -1)] = 1.0
    in2 = np.flatnonzero(dtmp < - 1.0)
    dtmp[(in2 -1)] = - 1.0
    # convert to meters for earth distance
    ad = acos(dtmp)
    d = (111.112) * raddeg * ad
    # now find heading
    hdgcos = (sinlat2 - sinlat1 * cos(ad)) / (sin(ad) * coslat1)
    # check value to be legal range
    in1 = np.flatnonzero(hdgcos > 1.0)
    hdgcos[(in1 -1)] = 1.0
    in2 = np.flatnonzero(hdgcos < - 1.0)
    hdgcos[(in2 -1)] = - 1.0
    hdg = acos(hdgcos) * raddeg
    # if longitude is decreasing then heading is between 180 and 360
    test = sin(lon2 - lon1)
    in1 = np.flatnonzero(test > 0.0)
    hdg[(in1 -1)] = 360 - hdg[(in1 -1)]
    return d, hdg
