# Autogenerated with SMOP version 0.23
# main.py ../t_tide1.3/t_synth.m -o ../t_tide_py/t_synth.py
from __future__ import division
import numpy as np
from scipy.io import loadmat,savemat
import os

def t_synth(varargin):
    """T_SYNTH Monte-Carlo test of the error estimation using synthetic data
     A single test of the harmonic analysis involves:

       1) Generation of a "pure" tidal signal with known constituents.
       2) Contamination with noise (according to some statistical model).
       3) The harmonic analysis resulting in constituent estimates.
       4) Generation of confidence intervals for the estimates.

     T_SYNTH runs multiple realizations of this sequence. In each 
     realization, the added noise is different (but its statistical model
     remains the same).  Statistically, one would hope that the "true" 
     constituent components were somewhere within the 95
     CI 95
     of the 
     time. Almost equivalently, the width of the 95
     CI should match the
     95
    -width of the histogram of estimates. The resulting plot shows 
     the histogram of estimates, their 95
     width, and the width of 95

     CI for all realizations.

     A variety of input parameters can be specified:

           'freqs':   Frequencies to use (default {'M2','K1','S2'} ).

           'tidecon': Constituents in run for specified frequencies in
                      the form of a matrix with one row per constituent.
                      Each row is of the form 
                       [semi-major_axis_length, semi-minor_axis_length,
                        ellipse_inclination (deg), Greenwich_phase (deg)]'
                      If only one row is given, the same parameters are
                      used for all constituents.
                      default: [1 .1 45 60]

                      If you want to test things for a "real" time series,
                      (e.g., an elevation series), set the two middle
                      parameters to 0 - e.g., [1 0 0 60].

           'time':    Time axis (hours) default [0:24*60] 

           'nrun':    Number of simulations (default 100);

           'error':   Formula for errors to be added to simulation (to be
                      used in an EVAL statement). If the size of the 
                      synthesized data matrix is needed, replace with SY. 
                      Examples (of correlated bivariate gaussian white 
                      noise) are:

                        '.5*randn(SY)'
                        '(1*randn(SY)*1+1e-6*i*randn(SY))*exp(i*pi/4)'

                      To get coloured noise, use the implicit function
                      'colrand': e.g. to get noise with a wavenumber slope
                      of -1.1

                        '.5*colrand(SY,-1.1)';

           'boota':   Bootstrap analysis. Either
                       'c': Assume coloured uncorrelated noise.
                       'w': Assume white bivariate noise.

       Outputs: While running different realizations, text is output to
       the console. Upon completion, a figure is drawn, in which coloured
       histograms (a different colour for each constituent) of the 
       stimated values of all realizations are drawn. + and - 2.5

       percentiles are indicated with thick dashed bars (these limits are
       taken as 1.96 * the standard deviation). Uncertainties for each 
       realization are shown by thin solid lines; these should lie on top
       of the thicker dashed curves if the error analysis is correct.  The 
       upper set of plots uses the bootstrapped confidence intervals, and 
       the lower set a 'linear' analysis.

     R. Pawlowicz 6/5/00
                 11/2/00 - Added linear analysis.
     Version 1.0
    """
    const = t_getconsts
    # Defaults
    freqs = ['M2', 'K1', 'S2']
    #   May Min Inc Gphase
    tcon = np.array([1, 0.1, 45, 60]).reshape(1, -1)
    t = np.array([range(0, (np.dot(24, 60) +1))]).reshape(1, -1)
    nrun = 100
    errstr = '.5*randn(SY)+.5*i*randn(SY)'
    boota = 'c'
    while max(varargin.shape) > 0:

        if isstr(varargin[0]):
            if 'fre' == lower(varargin[-5](range(1, 4))):
                freqs = varargin[1]
            else:
                if 'tid' == lower(varargin[-5](range(1, 4))):
                    tcon = varargin[1]
                else:
                    if 'tim' == lower(varargin[-5](range(1, 4))):
                        t = varargin[1]
                    else:
                        if 'nru' == lower(varargin[-5](range(1, 4))):
                            nrun = varargin[1]
                        else:
                            if 'err' == lower(varargin[-5](range(1, 4))):
                                errstr = varargin[1]
                            else:
                                if 'boo' == lower(varargin[-5](range(1, 4))):
                                    boota = varargin[1]
                                else:
                                    error("Can't understand property:" + varargin[0])
            varargin[(np.array([1, 2]).reshape(1, -1) -1)] = np.array([])

    t = t - mean(t)
    nrunreq = max(freqs.shape)
    freq = np.zeros(shape=(nrunreq, 1), dtype='float64')
    for k in range(1, (nrunreq +1)):
        freq[(k -1)] = const.freq(strmatch(freqs[(k -1)], const.name))
    if tcon.shape[0] == 1:
        tcon = tcon[(np.ones(shape=(nrunreq, 1), dtype='float64') -1), :]
    tscmplx = 1
    if not  (any(tcon[:, 1]) | any(tcon[:, 2])):
        tscmplx = 0
    ap = (tcon[:, 0] + tcon[:, 1]) / 2
    am = (tcon[:, 0] - tcon[:, 1]) / 2
    em = np.dot((tcon[:, 2] + tcon[:, 3]), pi) / 180
    ep = np.dot((tcon[:, 2] - tcon[:, 3]), pi) / 180
    sm = np.zeros(shape=(nrunreq, 8, nrun), dtype='float64')
    lm = np.zeros(shape=(nrunreq, 8, nrun), dtype='float64')
    for k in range(1, (nrun +1)):
        y = np.sum((np.dot((ap * exp(np.dot(i, ep))), np.ones(shape=(1, max(t.shape)), dtype='float64'))) * exp(np.dot(np.dot(np.dot(np.dot(i, 2), pi), freq), t)) + (np.dot((am * exp(np.dot(i, em))), np.ones(shape=(1, max(t.shape)), dtype='float64'))) * exp(np.dot(np.dot(np.dot(np.dot(- i, 2), pi), freq), t)))
        SY = y.shape
        eval_('y=y+' + errstr + ';')
        fprintf('\n %d/\n %d\\n', k, nrun)
        nameu, fu, tidecon, xout = t_tide(y, 'interval', t[1] - t[0], 'output', 'none', 'rayleigh', freqs, 'error', boota + 'boot') # nargout=4
        nameu2, fu2, tidecon2, xout2 = t_tide(y, 'interval', t[1] - t[0], 'output', 'none', 'rayleigh', freqs, 'error', 'linear') # nargout=4
        I = np.zeros(shape=(nrunreq, 1), dtype='float64')
        for l in range(1, (nrunreq +1)):
            I[(l -1)] = strmatch(freqs[(l -1)], nameu)
        if tscmplx:
            sm[:, :, (k -1)] = tidecon[(I -1), :]
            lm[:, :, (k -1)] = tidecon2[(I -1), :]
        else:
            sm[:, (np.array([1, 2, 7, 8]).reshape(1, -1) -1), (k -1)] = tidecon[(I -1), :]
            lm[:, (np.array([1, 2, 7, 8]).reshape(1, -1) -1), (k -1)] = tidecon2[(I -1), :]
    for k in range(1, (sm.shape[0] +1)):
        ii = sm[(k -1), 6, :] - tcon[(k -1), 3] > 180
        sm[(k -1), 6, (ii -1)] = sm[(k -1), 6, (ii -1)] - 360
        ii = sm[(k -1), 6, :] - tcon[(k -1), 3] < - 180
        sm[(k -1), 6, (ii -1)] = sm[(k -1), 6, (ii -1)] + 360
        ii = lm[(k -1), 6, :] - tcon[(k -1), 3] > 180
        lm[(k -1), 6, (ii -1)] = lm[(k -1), 6, (ii -1)] - 360
        ii = lm[(k -1), 6, :] - tcon[(k -1), 3] < - 180
        lm[(k -1), 6, (ii -1)] = lm[(k -1), 6, (ii -1)] + 360
    SM = sm
    lbl = 'boot'
    if boota == 'c':
        lbl = 'Coloured Boot'
    else:
        lbl = 'White Boot'
    for e in np.array([0, 4]).reshape(1, -1):
        if e == 4:
            SM = lm
            lbl = 'linear'
        subplot(2, 4, 1 + e)
        hist(squeeze(SM[:, 0, :]).T)
        SS = np.dot(1.96, std(squeeze(SM[:, 0, :]).T).T)
        MM = mean(squeeze(SM[:, 0, :]).T).T
        line((np.array([MM, MM]).reshape(1, -1) + np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((np.array([MM, MM]).reshape(1, -1) - np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((tcon[:, (np.ones(shape=(1, nrun), dtype='float64') -1)] + squeeze(SM[:, 1, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        line((tcon[:, (np.ones(shape=(1, nrun), dtype='float64') -1)] - squeeze(SM[:, 1, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        title('Umajor (' + lbl + ')')
        subplot(2, 4, 2 + e)
        hist(squeeze(SM[:, 2, :]).T)
        SS = np.dot(1.96, std(squeeze(SM[:, 2, :]).T).T)
        MM = mean(squeeze(SM[:, 2, :]).T).T
        line((np.array([MM, MM]).reshape(1, -1) + np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((np.array([MM, MM]).reshape(1, -1) - np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((tcon[:, (np.dot(2, np.ones(shape=(1, nrun), dtype='float64')) -1)] + squeeze(SM[:, 3, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        line((tcon[:, (np.dot(2, np.ones(shape=(1, nrun), dtype='float64')) -1)] - squeeze(SM[:, 3, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        title('Uminor (' + lbl + ')')
        subplot(2, 4, 3 + e)
        hist(squeeze(SM[:, 4, :]).T)
        SS = np.dot(1.96, std(squeeze(SM[:, 4, :]).T).T)
        MM = mean(squeeze(SM[:, 4, :]).T).T
        line((np.array([MM, MM]).reshape(1, -1) + np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((np.array([MM, MM]).reshape(1, -1) - np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((tcon[:, (np.dot(3, np.ones(shape=(1, nrun), dtype='float64')) -1)] + squeeze(SM[:, 5, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        line((tcon[:, (np.dot(3, np.ones(shape=(1, nrun), dtype='float64')) -1)] - squeeze(SM[:, 5, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        title('Inclination (' + lbl + ')')
        xlabel('              --: Actual 95\n % CI     -: Estimated 95\n % CI', 'fontweight', 'bold')
        subplot(2, 4, 4 + e)
        hist(squeeze(SM[:, 6, :]).T)
        SS = np.dot(1.96, std(squeeze(SM[:, 6, :]).T).T)
        MM = mean(squeeze(SM[:, 6, :]).T).T
        line((np.array([MM, MM]).reshape(1, -1) + np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((np.array([MM, MM]).reshape(1, -1) - np.array([SS, SS]).reshape(1, -1)).T, np.array([0, nrun / 5]).reshape(1, -1), 'linewidth', 3, 'linest', '--')
        line((tcon[:, (np.dot(4, np.ones(shape=(1, nrun), dtype='float64')) -1)] + squeeze(SM[:, 7, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        line((tcon[:, (np.dot(4, np.ones(shape=(1, nrun), dtype='float64')) -1)] - squeeze(SM[:, 7, :])).T, np.array([range(0, (nrun - 1 +1))]).reshape(1, -1) / 5)
        title('G-phase (' + lbl + ')')
    if nargout == 0:
        clear('sm', 'lm', 'tcon')
    #----------------------------------------------------------------------
    return sm, lm, tcon
def colrand(SY, slp):
    """COLRAND generates coloured noise
     Version 1.0
    """
    lSY = np.max(SY)
    f = np.array([1, range(1, (floor(lSY / 2) +1)), range(- ceil(lSY / 2) + 1, (- 1 +1))]).reshape(1, -1) / (lSY)
    x = randn(SY)
    x2 = (abs(f) ** slp) * fft(x)
    A = real(ifft(x2))
    A = A / std(A)
    #plot([1:max(SY)]',[x' A']);
    return A
