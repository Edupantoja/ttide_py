# Autogenerated with SMOP version 0.23
# main.py ../t_tide1.3/t_equilib.m -o ../t_tide_py/t_equilib.py
from __future__ import division
import numpy as np
from scipy.io import loadmat,savemat
import os

def t_equilib(lat):
    """T_EQUILIB Equilibrium amplitude of the tidal potential
     [NAME,FREQ,AMPLITUDE]=T_EQUILIB(LAT) returns vectors with the 
     NAME of tidal constituents, their FREQ (in cph), and their 
     equilibrium AMPLITUDE in the tidal potential as a function of 
     LATitude (degrees). If LAT is a vector, then AMPLITUDE is a 
     matrix in which each column corresponds to a specific latitude.

     If no output arguments are specified, the equilibrium spectrum
     is plotted.
     R. Pawlowicz 9/11/99
     Version 1.0
    """
    const = t_get18consts
    g = 9.81
    # m/s^2;
    erad = 6365
    # km
    earthmoond = 384000.0
    # km
    Mmoon = 7.38e+22
    # kg
    Mearth = 5.977e+24
    # kg
    Gravconst = 6.658e-11
    # m^3/kg/s^2
    # There appears to be a typo in Godin's text, and this
    # should likely be checked against Doodson's original.
    # This is what I *think* it should be.
    G = np.dot(np.dot(3 / 4, Mmoon), (np.dot(erad, 1000.0)) ** 3) / (np.dot(earthmoond, 1000.0)) ** 2 / Mearth
    # The 4/3 is to correct for the 3/4 in G
    gfac = np.dot(np.dot(Gravconst, Mearth) / (np.dot(erad, 1000.0)) ** 2, (4 / 3))
    jk = finite(const.doodsonamp)
    freq = const.freq(jk)
    name = const.name(jk, :)
    slat = sin(np.dot(lat[:].T, pi) / 180)
    clat = cos(np.dot(lat[:].T, pi) / 180)
    G1 = np.zeros(shape=(6, max(clat.shape)), dtype='float64')
    # Latitude dependence of amplitude for various species -
    # + for A, -for B (from Godin, 1972).
    G1[(3 + 0 -1), :] = np.dot(np.dot(0.5, G), (1 - np.dot(3, slat ** 2)))
    G1[(3 - 1 -1), :] = np.dot(np.dot(2, G), slat) * clat
    G1[(3 + 1 -1), :] = np.dot(np.dot(0.72618, G), clat) * (1 - np.dot(5, slat ** 2))
    G1[(3 - 2 -1), :] = np.dot(np.dot(2.59808, G), slat) * clat ** 2
    G1[(3 + 2 -1), :] = np.dot(G, clat ** 2)
    G1[(3 + 3 -1), :] = np.dot(G, clat ** 3)
    amp = abs(const.doodsonamp(jk, np.ones(shape=(1, max(clat.shape)), dtype='float64')) / gfac * G1[(const.doodsonspecies(jk) + 3 -1), :])
    if nargout == 0:
        cols = np.array([1, 0, 0, 0, 1, 0, 0, 0, 1, 0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5]).reshape(1, -1)
        set_(gcf, 'defaultaxescolororder', cols[(const.doodsonspecies(jk) + 3 -1), :])
        semilogy(np.dot(24, np.array([freq, freq]).reshape(1, -1).T), np.array([repmat(np.min(amp), max(amp.shape), 1), amp]).reshape(1, -1).T)
        cnam = cellstr(name)
        for k in range(1, (max(cnam.shape) +1)):
            cnam[(k -1)] = deblank(cnam[(k -1)])
            ff = np.min(np.array([np.flatnonzero(abs(cnam[(k -1)](range(2, (end +1)))) >= abs('0') & abs(cnam[(k -1)](range(2, (end +1)))) <= abs('9')) + 1, max(cnam[(k -1)].shape) + 1]).reshape(1, -1))
            cnam[(k -1)] = cnam[(k -1)](range(1, (ff - 1 +1))) + '_{' + cnam[(k -1)](range(ff, (end +1))) + '}'
        text(np.dot(freq, 24), amp, cnam, 'vertical', 'bottom', 'horiz', 'center', 'fontangle', 'italic', 'fontweight', 'bold', 'clip', 'on', 'fontsize', 9)
        xlabel('Frequency (cpd)')
        ylabel('Potential (m)')
        set_(gca, 'tickdir', 'out', 'ylim', np.array([np.min(amp), np.dot(np.max(amp), 2)]).reshape(1, -1))
    return name, freq, amp
