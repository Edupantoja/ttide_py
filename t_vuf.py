# Autogenerated with SMOP version 0.23
# main.py ../t_tide1.3/t_vuf.m -o ../t_tide_py/t_vuf.py
from __future__ import division
import numpy as np
from scipy.io import loadmat,savemat
import os

def t_vuf(*varargin):
    """T_VUF Computes nodal modulation corrections.
     [V,U,F]=T_VUF(TYPE,DATE,JU,LAT) returns the astronomical phase V, the 
     nodal phase modulation U, and the nodal amplitude correction F at
     a decimal date DATE for the components specified by index JU 
     at a latitude LAT.

     TYPE is either 'full' for the 18.6 year set of constitunets, or 'nodal'
     for the 1-year set with satellite modulations.

     If LAT is not specified, then the Greenwich phase V is computed with
     U=0 and F=1. 

     Note that V and U are in 'cycles', not degrees or radians (i.e.,
     multiply by 360 to get degrees).

     If LAT is set to NaN, then the nodal corrections are computed for all
     satellites that do *not* have a "latitude-dependent" correction 
     factor. This is for compatibility with the ways things are done in
     the xtide package. (The latitude-dependent corrections were zeroed
     out there partly because it was convenient, but this was rationalized
     by saying that since the forcing of tides can occur at latitudes
     other than where they are observed, the idea that observations have 
     the equilibrium latitude-dependence is possibly bogus anyway).
     R. Pawlowicz 11/8/99
                   1/5/00 - Changed to allow for no LAT setting.
                  11/8/00 - Added the LAT=NaN option.
                  10/02/03 - Suuport for 18-year (full) constituent set.
     Version 1.2
     Get all the info about constituents.
     Calculate astronomical arguments at mid-point of data time series.
    """
    nargin = len(varargin)
    if nargin > 0:
        ltype = varargin[0]
    if nargin > 1:
        ctime = varargin[1]
    if nargin > 2:
        ju = varargin[2]
    if nargin > 3:
        lat = varargin[3]
    astro, ader = t_astron(ctime) # nargout=2
    if ltype == 'full':
        const = t_get18consts(ctime)
        # Phase relative to Greenwich (in units of cycles).
        v = rem(np.dot(const.doodson, astro) + const.semi, 1)
        v = v[(ju -1)]
        u = np.zeros(shape=(v.shape, v.shape), dtype='float64')
        f = np.ones(shape=(v.shape, v.shape), dtype='float64')
    else:
        const, sat, shallow = t_getconsts(ctime) # nargout=3
        # Phase relative to Greenwich (in units of cycles).
        # (This only returns values when we have doodson#s, i.e., not for the 
        # shallow water components, but these will be computed later.)
        v = rem(np.dot(const.doodson, astro) + const.semi, 1)
        if nargin == 4:
            # If we have a latitude, get nodal corrections.
            # Apparently the second-order terms in the tidal potential go to zero
            # at the equator, but the third-order terms do not. Hence when trying
            # to infer the third-order terms from the second-order terms, the 
            # nodal correction factors blow up. In order to prevent this, it is 
            # assumed that the equatorial forcing is due to second-order forcing 
            # OFF the equator, from about the 5 degree location. Latitudes are 
            # hence (somewhat arbitrarily) forced to be no closer than 5 deg to 
            # the equator, as per note in Foreman.
            if isfinite(lat) & (abs(lat) < 5):
                lat = sign(lat) * 5
            slat = sin(pi * lat / 180)
            # Satellite amplitude ratio adjustment for latitude. 
            rr = sat.amprat
            # no amplitude correction
            if isfinite(lat):
                j = np.flatnonzero(sat.ilatfac == 1)
                # latitude correction for diurnal constituents
                rr[(j -1)] = rr[(j -1)] * 0.36309 * (1.0 - 5.0 * slat * slat) / slat
                j = np.flatnonzero(sat.ilatfac == 2)
                # latitude correction for semi-diurnal constituents
                rr[(j -1)] = rr[(j -1)] * 2.59808 * slat
            else:
                rr[sat.ilatfac > 0] = 0
            # Calculate nodal amplitude and phase corrections.
            uu = rem(np.dot(sat.deldood, astro[3:6]) + sat.phcorr, 1)
            #uu=uudbl-round(uudbl);  <_ I think this was wrong. The original
            #                         FORTRAN code is:  IUU=UUDBL
            #                                           UU=UUDBL-IUU
            #                         which is truncation.        
            # Sum up all of the satellite factors for all satellites.
            nsat = max(sat.iconst.shape)
            nfreq = max(const.isat.shape)
            fsum = 1 + np.sum(sparse(np.array([range(1, (nsat +1))]).reshape(1, -1), sat.iconst, double(rr * exp(np.dot(np.dot(np.dot(i, 2), pi), uu))), nsat, nfreq)).T
            f = abs(fsum)
            u = angle(fsum) / (np.dot(2.0, pi))
            # Compute amplitude and phase corrections for shallow water constituents. 
            for k in np.flatnonzero(isfinite(const.ishallow)).T:
                ik = const.ishallow(k) + np.array([range(0, (const.nshallow(k) - 1 +1))]).reshape(1, -1)
                f[(k -1)] = prod(f[(shallow.iname(ik) -1)] ** abs(shallow.coef(ik)))
                u[(k -1)] = np.sum(u[(shallow.iname(ik) -1)] * shallow.coef(ik))
                v[(k -1)] = np.sum(v[(shallow.iname(ik) -1)] * shallow.coef(ik))
            f = f[(ju -1)]
            u = u[(ju -1)]
            v = v[(ju -1)]
        else:
            # Astronomical arguments only, so nodal corrections.
            # Compute phases for shallow water constituents.
            for k in np.flatnonzero(isfinite(const.ishallow)).T:
                ik = const.ishallow(k) + np.array([range(0, (const.nshallow(k) - 1 +1))]).reshape(1, -1)
                v[(k -1)] = np.sum(v[(shallow.iname(ik) -1)] * shallow.coef(ik))
            v = v[(ju -1)]
            f = np.ones(shape=(v.shape, v.shape), dtype='float64')
            u = np.zeros(shape=(v.shape, v.shape), dtype='float64')
    return v, u, f
